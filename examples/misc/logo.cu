/*Raul P. Pelaez 2019. The UAMMD letters made of particles suspended in a fluid.

Runs a Brownian Hydrodynamics simulation with particles starting in a periodic box at low temperature.

Reads some parameters from a "data.main.logo" file, which will be autogenerated if not present.
You can visualize the reuslts with superpunto

*/

//This include contains the basic needs for an uammd project
#include"uammd.cuh"
#include"Integrator/BDHI/BDHI_EulerMaruyama.cuh"
#include"Integrator/BDHI/BDHI_FCM.cuh"
#include"Interactor/ExternalForces.cuh"
#include"utils/InputFile.h"
#include<fstream>
using std::cerr;
using std::endl;
using std::ofstream;
using std::make_shared;
using namespace uammd;


#include"../.res/logo.c"

struct Faller: public ParameterUpdatable{
  real zwall;
  real k = 1.0;
  real g = 0.1;
  Faller(real zwall):zwall(zwall){
  }

  __device__ __forceinline__ real3 force(const real4 &pos){
    real fz = 0;
    if(pos.z<=zwall)fz += k*pow(fabs(pos.z-zwall),2.0f);
    return make_real3(0.0f, 0.0f, fz-g);
  }

  std::tuple<const real4 *> getArrays(ParticleData *pd){
    auto pos = pd->getPos(access::location::gpu, access::mode::read);
    return std::make_tuple(pos.raw());
  }

  void updateSimulationTime(real time){
    //You can be aware of changes in some parameters by making the functor ParameterUpdatable
    //and overriding the update function you want, see misc/ParameterUpdatable.h for a list
  }
};
using std::make_shared;
using std::endl;

real3 boxSize;
real dt;
std::string outputFile;
int numberParticles;
int numberSteps, printSteps;
real temperature, viscosity, hydrodynamicRadius;
real tolerance = 1e-2;
void readParameters(std::shared_ptr<System> sys, std::string file);

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);
  readParameters(sys, "data.main.logo");

  ullint seed = 0xf31337Bada55D00dULL^time(NULL);
  sys->rng().setSeed(seed);

  auto pd = make_shared<ParticleData>(numberParticles, sys);

  Box box(boxSize);
  {
    auto pos = pd->getPos(access::location::cpu, access::mode::write);
    int i = 0;
    while(i < numberParticles){
      int w = uammd_image.width;
      int h =  uammd_image.height;
      real2 img_dim = make_real2(w,h);
      real2 tmp;
      do{
	tmp = make_real2(sys->rng().gaussian2(0.5, 1))*img_dim;
      }while(tmp.x<=0 or tmp.x >= w or tmp.y <=0 or tmp.y>=h-1);

      int2 pixel= make_int2( tmp.x+0.5, tmp.y+0.5);
      pixel.y = h-pixel.y-1;
      if(uammd_image.pixel_data[4*(pixel.y*w+pixel.x)] != '\0'){
	continue;
      }

      real2 pos_t = (tmp/img_dim-0.5);
      real fac = 1.01;
      pos_t = make_real2(fac*pos_t.x*boxSize.x, fac*pos_t.y*boxSize.x*(h/(real)w)+boxSize.z*0.5-fac*0.5*boxSize.x*(h/(real)w));
      pos[i] = make_real4(pos_t.x, sys->rng().uniform(-0.5, 0.5)*boxSize.y*0.25, pos_t.y, 0);
      i++;
    }
  }


  std::ofstream out(outputFile);
  real radius=0.7;

  BDHI::FCM::Parameters par;
  par.temperature = temperature;
  par.viscosity = viscosity;
  par.hydrodynamicRadius =  hydrodynamicRadius;
  par.dt = dt;
  par.box = box;
  par.tolerance = tolerance;
  //par.psi=0.3;
  auto bdhi = make_shared<BDHI::EulerMaruyama<BDHI::FCM>>(pd, sys, par);
  {
    auto extForces = make_shared<ExternalForces<Faller>>(pd, sys,
							 make_shared<Faller>(-box.boxSize.z*0.5));

    bdhi->addInteractor(extForces);
  }
  sys->log<System::MESSAGE>("RUNNING!!!");

  Timer tim;
  tim.tic();

  forj(0, numberSteps){
    if(j%printSteps==0)
    {
      sys->log<System::DEBUG1>("[System] Writing to disk...");

      auto pos = pd->getPos(access::location::cpu, access::mode::read);

      const int * sortedIndex = pd->getIdOrderedIndices(access::location::cpu);

      out<<"#Lx="<<boxSize.x*0.5<<";Ly="<<boxSize.y*0.5<<";Lz="<<boxSize.z*0.5<<";"<<endl;
      real3 p;
      fori(0, numberParticles){
	real4 pc = pos.raw()[sortedIndex[i]];
	p = make_real3(pc);
	int type = pc.w;
	out<<p<<" "<<radius<<" "<<type<<"\n";
      }
    }

    if(j%500 == 0){
      pd->sortParticles();
    }

    bdhi->forwardTime();
  }

  auto totalTime = tim.toc();
  sys->log<System::MESSAGE>("mean FPS: %.2f", numberSteps/totalTime);

  sys->finish();

  return 0;
}

void readParameters(std::shared_ptr<System> sys, std::string file){

  {
    if(!std::ifstream(file).good()){
      real visco = 1;
      std::ofstream default_options(file);
      default_options<<"boxSize 256 128 160"<<std::endl;
      default_options<<"numberParticles 400000"<<std::endl;
      default_options<<"dt 0.01"<<std::endl;
      default_options<<"numberSteps 50000"<<std::endl;
      default_options<<"printSteps 200"<<std::endl;
      default_options<<"outputFile /dev/stdout"<<std::endl;
      default_options<<"temperature 1.0"<<std::endl;
      default_options<<"viscosity "<<visco<<std::endl;
      default_options<<"hydrodynamicRadius 4"<<std::endl;
    }
  }

  InputFile in(file, sys);

  in.getOption("boxSize", InputFile::Required)>>boxSize.x>>boxSize.y>>boxSize.z;
  in.getOption("numberSteps", InputFile::Required)>>numberSteps;
  in.getOption("printSteps", InputFile::Required)>>printSteps;
  in.getOption("dt", InputFile::Required)>>dt;
  in.getOption("numberParticles", InputFile::Required)>>numberParticles;
  in.getOption("outputFile", InputFile::Required)>>outputFile;
  in.getOption("temperature", InputFile::Required)>>temperature;
  in.getOption("viscosity", InputFile::Required)>>viscosity;
  in.getOption("hydrodynamicRadius", InputFile::Required)>>hydrodynamicRadius;
  in.getOption("tolerance", InputFile::Optional)>>tolerance;
}